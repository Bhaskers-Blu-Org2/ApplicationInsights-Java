plugins {
    id 'java-library'
}

repositories {
    mavenCentral()
}


configurations {
    jni64 {
        transitive = false
    }
    jni32 {
        transitive = false
    }
    provided {
        transitive = false
    }
    compileOnly.extendsFrom provided
    testRuntime.extendsFrom provided
}

def jniSrcDir = 'src/main/jni'
sourceSets {
    main {
        java {
            srcDir jniSrcDir
        }
    }
}

dependencies {
    implementation 'org.apache.commons:commons-lang3:3.7'
    implementation 'commons-io:commons-io:2.6'
    implementation 'org.slf4j:slf4j-api:1.7.26'
    api 'ch.qos.logback:logback-classic:1.2.3'

    provided project(path: ':core')
    provided project(path: ':agent-codeless')

    jni32 project(path: ':etw:native', configuration: "${isRelease ? 'release' : 'debug'}X86RuntimeElements")
    jni64 project(path: ':etw:native', configuration: "${isRelease ? 'release' : 'debug'}X86-64RuntimeElements")

    testImplementation 'org.hamcrest:hamcrest-core:1.3'
    testImplementation 'org.hamcrest:hamcrest-library:1.3'
    testImplementation 'org.mockito:mockito-core:1.10.19'
    testImplementation 'junit:junit:4.12'
}

archivesBaseName = "applicationinsights-java-etw-provider"

tasks.register('generateNativeHeaders', Exec) {
    // could be made generic if more native classes existed

    def targetClass = 'com.microsoft.applicationinsights.internal.etw.EtwProvider'
    def outputDir = project(':etw:native').ext.headersDir
    def outputFilename = 'jni_etw_provider.h'

    workingDir buildDir
    commandLine "${System.env.JAVA_HOME}/bin/javah", "-jni", "-force", "-v", "-o", "$outputDir/$outputFilename", "-classpath", "$buildDir/classes/java/main", targetClass

    inputs.dir(file("$projectDir/$jniSrcDir"))
    outputs.file(file("$outputDir/$outputFilename"))

    doFirst {
        if (!file(outputDir).exists()) {
            throw new GradleException("output dir does not exists: $outputDir")
        }
    }
}

tasks.register('processNativeResources', Copy) {
    dependsOn project(':etw:native').tasks.named("assemble${isRelease ? 'Release' : 'Debug'}X86").get()
    dependsOn project(':etw:native').tasks.named("assemble${isRelease ? 'Release' : 'Debug'}X86-64").get()

    from configurations.jni32.files
    from configurations.jni64.files
    include '*.dll'
    into "${sourceSets.main.output.resourcesDir}"
}

tasks.named('processResources').configure {
    dependsOn 'processNativeResources'
    mustRunAfter 'generateNativeHeaders'
}

